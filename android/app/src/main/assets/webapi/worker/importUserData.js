let request,db;self.onmessage=async({data})=>{if(!db){await IDBinit()}self.postMessage({status:"Importing User Data"});const reader=new FileReader;reader.onload=async()=>{let fileContent;try{self.postMessage({progress:0});self.postMessage({progress:30});fileContent=JSON.parse(reader.result);self.postMessage({progress:75})}catch(e){console.error(e);fileContent=undefined}try{if(!fileContent){self.postMessage({progress:0});fileContent=await parseAsync(reader.result,reader.result.length).value;self.postMessage({progress:75})}if(!fileContent){self.postMessage({status:"File parsing has failed"});self.postMessage({error:"File parsing has failed"});return}let hasImportedData;await saveJSON(true,"shouldProcessRecommendation");const userData=fileContent?.userData;const username=userData?.username??fileContent?.username;const shouldImportUserEntries=username&&typeof username=="string";if(shouldImportUserEntries){self.postMessage({importedUsername:username})}self.postMessage({progress:76.10993657505286});const tagInfo=fileContent.tagInfo?new Date(fileContent.tagInfo):null;if(isJsonObject(tagInfo)&&!jsonIsEmpty(tagInfo)){await saveJSON(tagInfo,"tagInfo");hasImportedData=true}self.postMessage({progress:81.60676532769556});if(shouldImportUserEntries){const userEntries=userData?.userEntries;if(userEntries instanceof Array){await saveJSON({username:username,userEntries:userEntries},"userData");await saveJSON(fileContent.userAnimeUpdateAt,"userAnimeUpdateAt");hasImportedData=true}}const algorithmFilters=fileContent.algorithmFilters;if(algorithmFilters instanceof Array&&algorithmFilters?.length>0){self.postMessage({algorithmFilters:algorithmFilters});await saveJSON(algorithmFilters,"algorithmFilters");hasImportedData=true}self.postMessage({progress:82.87526427061312});const userList=fileContent.userList;const hiddenEntries=userList?.hiddenEntries;const categories=userList?.categories;const selectedCategory=userList?.selectedCategory;const animeCautions=userList?.animeCautions;const category=categories?.[selectedCategory];if(isJsonObject(hiddenEntries)&&typeof selectedCategory==="string"&&animeCautions instanceof Array&&category?.animeFilters instanceof Array&&category?.animeList instanceof Array&&typeof category?.isHiddenList==="boolean"&&typeof category?.sortBy?.sortName==="string"&&typeof category?.sortBy?.sortType==="string"){self.postMessage({animeCautions:animeCautions});self.postMessage({importedHiddenEntries:hiddenEntries});await saveJSON(userList,"userList");hasImportedData=true}self.postMessage({progress:94.08033826638479});const animeEntries=fileContent.animeEntries;const excludedEntries=fileContent.excludedEntries;const entriesVersion=fileContent.entriesVersion;let animeUpdateAt=fileContent.animeUpdateAt||1706674120;let currentAnimeUpdateAt=await retrieveJSON("animeUpdateAt")||1706674120;let shouldImportAniEntries=animeUpdateAt>currentAnimeUpdateAt&&animeUpdateAt&&isJsonObject(animeEntries)&&!jsonIsEmpty(animeEntries)||entriesVersion&&entriesVersion>(await retrieveJSON("entriesVersion")??0)||Object.keys(await retrieveJSON("animeEntries")||{}).length<Object.keys(fileContent.animeEntries||{}).length;if(shouldImportAniEntries){await saveJSON(animeEntries,"animeEntries");await saveJSON(excludedEntries,"excludedEntries");await saveJSON(entriesVersion,"entriesVersion");await saveJSON(animeUpdateAt,"animeUpdateAt");hasImportedData=true}await saveJSON(true,"shouldProcessRecommendation");if(hasImportedData){self.postMessage({status:"Data has been Imported"});self.postMessage({status:null});self.postMessage({progress:100});self.postMessage({message:"success"})}else{self.postMessage({status:typeof error==="string"?error:"Something went wrong"});self.postMessage({status:null});self.postMessage({progress:100});self.postMessage({error:"Something went wrong"})}}catch(error){console.error(error);self.postMessage({status:typeof error==="string"?error:"Something went wrong"});self.postMessage({progress:100});self.postMessage({error:error})}};reader.onerror=error=>{console.error(error);self.postMessage({status:typeof error==="string"?error:"Something went wrong"});self.postMessage({progress:100});self.postMessage({error:error})};if(reader.readyState!==1){reader.readAsText(data.importedFile)}else{reader.onabort=()=>{reader.readAsText(data.importedFile)};reader.abort()}};async function IDBinit(){return await new Promise(resolve=>{let request=indexedDB.open("Kanshi.Anime.Recommendations.Anilist.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onerror=error=>{console.error(error)};request.onsuccess=event=>{db=event.target.result;return resolve()};request.onupgradeneeded=event=>{db=event.target.result;db.createObjectStore("MyObjectStore");let transaction=event.target.transaction;transaction.oncomplete=()=>{return resolve()}}})}async function saveJSON(data,name){return await new Promise(async(resolve,reject)=>{try{let write=db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").openCursor();write.onsuccess=async event=>{let put=await db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").put(data,name);put.onsuccess=event=>{return resolve()};put.onerror=event=>{return resolve()}};write.onerror=async error=>{console.error(error);return reject()}}catch(ex){console.error(ex)}})}async function retrieveJSON(name){return await new Promise(resolve=>{try{let read=db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").get(name);read.onsuccess=()=>{return resolve(read.result)};read.onerror=error=>{console.error(error);return resolve()}}catch(ex){console.error(ex);return resolve()}})}function isValidJson(j){let construct=j?.constructor.name;try{return construct==="Object"&&`${j}`==="[object Object]"||j instanceof Array||construct==="Array"}catch(e){return false}}function isJsonObject(obj){return Object.prototype.toString.call(obj)==="[object Object]"}function jsonIsEmpty(obj){for(const key in obj){return false}return true}function parseAsync(text,textLength){if(isValidJson(text)){return text}else if(!(typeof text==="string"||text instanceof String)){throw new Error(`Input Text has Unexpected Type of ${text?.constructor?.name||typeof text}`,{cause:JSON.stringify(text)})}let streamDone=true,wait={},waitToFinish;return{value:new Promise(async resolve=>{let at=-1;let ch="";const maxByteSize=32*1024;let textProcessed=0;let garbageChunk=()=>{if(at>=maxByteSize){textProcessed+=at;let progress=textProcessed/textLength*100*.75;self.postMessage({progress:progress});if(progress>.01){self.postMessage({status:`${progress.toFixed(2)}% Importing User Data`})}text=text.slice(at);at=0}};let waitForNextChunk=async()=>{if(wait?.promise){await wait.promise}else{wait.promise=new Promise(resolve=>{wait.resolve=resolve});await wait.promise}wait={}};let seek=async(added=1)=>{let newAt=at+added;while(true){ch=text.charAt(newAt);if(ch){if(ch<=" "){newAt+=1;continue}at=newAt;garbageChunk();break}if(streamDone){at=newAt;garbageChunk();break}await waitForNextChunk()}};let wordCheck=async()=>{let word="";do{word+=ch;await seek()}while(ch.match(/[a-z]/i));return word};let isPrimitive=true;let normalizeUnicodedString=async quote=>{let inQuotes="";let hasCompleteString=false;let startIndexNotIncluded=at;let endIndexNotIncluded=0;let slashCount=0;let removedFirstQuote=false;while(quote){endIndexNotIncluded=text.indexOf(quote,startIndexNotIncluded+1);if(endIndexNotIncluded<0){if(streamDone)break;await waitForNextChunk();continue}ch=text.charAt(endIndexNotIncluded-1);while(ch==="\\"){slashCount++;ch=text.charAt(endIndexNotIncluded-(slashCount+1))}if(!removedFirstQuote){removedFirstQuote=true;startIndexNotIncluded+=1}if(slashCount%2!==0){slashCount=0;inQuotes+=text.substring(startIndexNotIncluded,endIndexNotIncluded);startIndexNotIncluded=endIndexNotIncluded}else{if(isPrimitive){await waitToFinish;let nonWhiteSpace=/[^ ]*/g;const endOfStringIndex=endIndexNotIncluded+2;nonWhiteSpace.lastIndex=endOfStringIndex;const match=nonWhiteSpace.exec(text);const matchStr=match?.[0];const errorIndex=match?.index;if(matchStr&&errorIndex>=endOfStringIndex){throw error("Unexpected non-whitespace character after JSON",errorIndex)}inQuotes+=text.substring(startIndexNotIncluded,endIndexNotIncluded);hasCompleteString=true}else{inQuotes+=text.substring(startIndexNotIncluded,endIndexNotIncluded);hasCompleteString=true;await seek(inQuotes.length+2)}break}}if(hasCompleteString){let stringifiedValue=`"${inQuotes}"`;return JSON.parse(stringifiedValue)}else{throw error("Unterminated string in JSON")}};let error=(message,errorIndex)=>{return new Error(`${message} at position ${errorIndex??at} (${text.charAt(errorIndex??at)})`,{cause:JSON.stringify(text)})};async function parseAsync(){let quote;let wordToFind;let isFirstKey;switch(ch){case"{":isPrimitive=false;let returnObj={};await seek();if(ch==="}"){await seek();return returnObj}else if(ch!==`"`){throw error("Expected property name or '}' in JSON")}isFirstKey=true;let lastCh;do{if(isFirstKey){isFirstKey=false}else if(ch===","){lastCh=ch;await seek()}else{throw error("Expected ',' or '}' after property value in JSON")}let key=await parseAsync();if(ch===":"){lastCh=ch;await seek()}else{throw error("Expected ':' after property name in JSON")}returnObj[key]=await parseAsync();if(ch==="}"){await seek();return returnObj}}while(ch===",");if(lastCh===","){throw error("Expected double-quoted property name in JSON")}else if(lastCh===":"){throw error("Unexpected end of JSON input")}else if(jsonIsEmpty(returnObj)){throw error("Expected property name or '}' in JSON")}else{throw error("Expected ',' or '}' after property value in JSON")}case"[":isPrimitive=false;let returnArr=[];await seek();if(ch==="]"){await seek();return returnArr}isFirstKey=true;do{if(isFirstKey){isFirstKey=false}else if(ch===","){await seek()}else{throw error(returnArr.length?"Expected ',' or ']' after array element":"Unexpected end of JSON input")}let value=await parseAsync();returnArr.push(value);if(ch==="]"){await seek();return returnArr}}while(ch===",");throw error(returnArr.length?"Expected ',' or ']' after array element":"Unexpected end of JSON input");case'"':quote=ch;if(text.length<2){if(streamDone){throw error("Unterminated string in JSON")}else{await waitForNextChunk()}}if(text.charAt(at+1)===quote){if(isPrimitive){await waitToFinish;const endOfStringIndex=at+2;let nonWhiteSpace=/[^ ]*/g;nonWhiteSpace.lastIndex=endOfStringIndex;const match=nonWhiteSpace.exec(text);const matchStr=match?.[0];const errorIndex=match?.index;if(matchStr&&errorIndex>=endOfStringIndex){throw error("Unexpected non-whitespace character after JSON",errorIndex)}}else{await seek(2)}return""}else{return await normalizeUnicodedString(quote)}case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"-":let numHolder="";let addUpNumberStr=async()=>{numHolder+=ch;await seek()};if(ch==="-"||ch==="+"){await addUpNumberStr()}let afterDecimal=ch===".";let afterExponential;if(afterDecimal){await addUpNumberStr()}while(isFinite(ch)&&ch!==""){await addUpNumberStr();if(!afterDecimal&&ch==="."){afterDecimal=true;await addUpNumberStr()}else if(!afterExponential&&(ch==="e"||ch==="E")){afterExponential=true;await addUpNumberStr();if(ch==="+"||ch==="-"){await addUpNumberStr()}}}const num=Number(numHolder);if(isNaN(num)){const errorIndex=at-numHolder.length;throw error("Invalid Number",errorIndex)}else{if(isPrimitive){await waitToFinish;const indexAfterNumber=at;let nonWhiteSpace=/[^ ]*/g;nonWhiteSpace.lastIndex=indexAfterNumber;const match=nonWhiteSpace.exec(text);const matchStr=match?.[0];const errorIndex=match?.index;if(matchStr&&errorIndex>=indexAfterNumber){throw error("Unexpected non-whitespace character after JSON",errorIndex)}}return num}case"t":word=await wordCheck();wordToFind="true";if(word===wordToFind){if(isPrimitive){await waitToFinish;const indexAfterWord=at;let nonWhiteSpace=/[^ ]*/g;nonWhiteSpace.lastIndex=indexAfterWord;const match=nonWhiteSpace.exec(text);const matchStr=match?.[0];const errorIndex=match?.index;if(matchStr&&errorIndex>=indexAfterWord){throw error("Unexpected non-whitespace character after JSON",errorIndex)}}return true}else{const wordLen=word.length;const wordToFindLen=wordToFind.length;if(wordLen>wordToFindLen){const errorIndex=at-(wordLen-wordToFindLen);throw error("Unexpected non-whitespace character after JSON",errorIndex)}else{const errorInWordIndex=at-1;throw error("Unexpected non-whitespace character after JSON",errorInWordIndex)}}case"f":word=await wordCheck();wordToFind="false";if(word===wordToFind){if(isPrimitive){await waitToFinish;const indexAfterWord=at;let nonWhiteSpace=/[^ ]*/g;nonWhiteSpace.lastIndex=indexAfterWord;const match=nonWhiteSpace.exec(text);const matchStr=match?.[0];const errorIndex=match?.index;if(matchStr&&errorIndex>=indexAfterWord){throw error("Unexpected non-whitespace character after JSON",errorIndex)}}return false}else{const wordLen=word.length;const wordToFindLen=wordToFind.length;if(wordLen>wordToFindLen){const errorIndex=at-(wordLen-wordToFindLen);throw error("Unexpected non-whitespace character after JSON",errorIndex)}else{const errorInWordIndex=at-1;throw error("Unexpected non-whitespace character after JSON",errorInWordIndex)}}case"n":word=await wordCheck();wordToFind="null";if(word===wordToFind){if(isPrimitive){await waitToFinish;const indexAfterWord=at;let nonWhiteSpace=/[^ ]*/g;nonWhiteSpace.lastIndex=indexAfterWord;const match=nonWhiteSpace.exec(text);const matchStr=match?.[0];const errorIndex=match?.index;if(matchStr&&errorIndex>=indexAfterWord){throw error("Unexpected non-whitespace character after JSON",errorIndex)}}return null}else{const wordLen=word.length;const wordToFindLen=wordToFind.length;if(wordLen>wordToFindLen){const errorIndex=at-(wordLen-wordToFindLen);throw error("Unexpected non-whitespace character after JSON",errorIndex)}else{const errorInWordIndex=at-1;throw error("Unexpected non-whitespace character after JSON",errorInWordIndex)}}default:throw error("Unexpected Token")}}await seek();resolve(await parseAsync())})}}