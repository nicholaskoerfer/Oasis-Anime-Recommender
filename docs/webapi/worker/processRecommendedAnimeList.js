let db;const mediaRelationTypes=["adaptation","prequel","sequel","parent","side_story","summary","alternative","spin_off"];self.onmessage=async({data})=>{try{if(!db)await IDBinit();self.postMessage({status:"Initializing Filters"});const animeEntries=await retrieveJSON("animeEntries")||{};const userData=await retrieveJSON("userData");const userEntries=(userData?.userEntries??await retrieveJSON("userEntries"))||[];let includedUserEntryCount;let contentFocused=false,includeUnknownVar=false,measure="mean",includeYear=true,includeAverageScore=false,minPopularity,minAverageScore,minSampleSize,sampleSize,tagRankLimit=0,customUserScoreBase,genresWithLowerCount={};let include={genres:{},tags:{},categories:{}},exclude={genres:{},tags:{},categories:{}};let selectedCustomFilter=data?.selectedCustomFilter;let activeTagFilters=data?.activeTagFilters;if(!selectedCustomFilter||!activeTagFilters){const userFilters=await retrieveJSON("userFilters");selectedCustomFilter=(userFilters?.selectedCustomFilter??await retrieveJSON("selectedCustomFilter"))||"Custom Filter";activeTagFilters=data?.activeTagFilters||(userFilters?.activeTagFilters??await retrieveJSON("activeTagFilters"))}let algorithmFilter=activeTagFilters?.[selectedCustomFilter]?.["Algorithm Filter"]||[];algorithmFilter.forEach(({selected,filterType,optionName,optionType,optionValue})=>{if(selected==="included"){if(filterType==="dropdown"){if(optionType==="genre"){include.genres["genre: "+optionName.toLowerCase()]=true}else if(optionType==="tag"){include.tags["tag: "+optionName.toLowerCase()]=true}else if(optionType==="tag category"){include.categories["tag category: "+optionName.toLowerCase()]=true}else if(optionType==="measure"){if(optionName.toLowerCase()==="mode"){measure="mode"}}}else if(filterType==="checkbox"){if(optionName.toLowerCase()==="content focused"){contentFocused=true}else if(optionName.toLowerCase()==="inc. all factors"){includeUnknownVar=true}else if(optionName.toLowerCase()==="inc. average score"){includeAverageScore=true}else if(optionName.toLowerCase()==="exclude year"){includeYear=false}}else if(filterType==="input number"){if(optionName.toLowerCase()==="min tag percentage"){tagRankLimit=parseFloat(optionValue)}else if(optionName.toLowerCase()==="scoring system"){customUserScoreBase=parseFloat(optionValue)}else if(optionName.toLowerCase()==="sample size"){sampleSize=parseFloat(optionValue)}else if(optionName.toLowerCase()==="min sample size"){minSampleSize=parseFloat(optionValue)}else if(optionName.toLowerCase()==="min popularity"){minPopularity=parseFloat(optionValue)}else if(optionName.toLowerCase()==="min average score"){minAverageScore=parseFloat(optionValue)}}}else if(selected==="excluded"){if(filterType==="dropdown"){if(optionType==="genre"){exclude.genres["genre: "+optionName.toLowerCase()]=true}else if(optionType==="tag"){exclude.tags["tag: "+optionName.toLowerCase()]=true}else if(optionType==="tag category"){exclude.categories["tag category: "+optionName.toLowerCase()]=true}}}});includedUserEntryCount=0;self.postMessage({status:"Analyzing User List"});if(userEntries.length>=2){if(typeof userEntries[0]?.score==="number"&&typeof userEntries[1]?.score==="number"&&typeof userEntries[0]?.media?.popularity==="number"&&typeof userEntries[1]?.media?.popularity==="number"){userEntries.sort((a,b)=>{let x=a?.score!=null?a.score:-Infinity,y=b?.score!=null?b.score:-Infinity;if(x!==y)return y-x;x=a?.media?.popularity!=null?a.media.popularity:-Infinity;y=b?.media?.popularity!=null?a.media.popularity:-Infinity;return y-x})}}let varScheme={genres:{},tags:{},studios:{}};let userEntriesStatus={userScore:{},userStatus:{}};let averageScore=[];let year=[];let genresMeanCount={};let tagsMeanCount={};let studiosMeanCount={};let includedAnimeRelations={};self.postMessage({status:"Processing User Schema"});for(let i=0;i<userEntries.length;i++){self.postMessage({progress:(i+1)/userEntries.length*100*.3});let anime=userEntries[i].media;let animeID=anime?.id;let status=userEntries[i].status;let userScore=userEntries[i]?.score;if(animeID){if(status){userEntriesStatus.userStatus[animeID]=status}if(userScore>0){userEntriesStatus.userScore[animeID]=userScore}}let genres=anime?.genres||[];let tags=anime?.tags||[];let studios=anime?.studios?.nodes||[];if(userScore>0){if(includedAnimeRelations[animeID])continue;includedAnimeRelations[animeID]=true;let animeRelations=anime?.relations?.edges||[];if(animeRelations instanceof Array){if(animeRelations.length>0){animeRelations.forEach(e=>{let animeRelationType=e?.relationType;let relationID=e?.node?.id;if(typeof animeRelationType==="string"&&typeof relationID==="number"){if(mediaRelationTypes.includes(animeRelationType.trim().toLowerCase())){includedAnimeRelations[relationID]=true}}})}}++includedUserEntryCount;for(let j=0;j<genres.length;j++){let genre=genres[j];if(typeof genre==="string"){let fullGenre="genre: "+genre.trim().toLowerCase();if((jsonIsEmpty(include.genres)||include.genres[fullGenre]||include.genres["genre: all"])&&!exclude.genres[fullGenre]&&!exclude.genres["genre: all"]){if(varScheme.genres[fullGenre]){varScheme.genres[fullGenre].userScore.push(userScore);++varScheme.genres[fullGenre].count}else{varScheme.genres[fullGenre]={userScore:[userScore],count:1}}if(genresMeanCount[fullGenre]){++genresMeanCount[fullGenre]}else{genresMeanCount[fullGenre]=1}}}}for(let j=0;j<tags.length;j++){let tagRank=tags[j]?.rank;if(tagRank<tagRankLimit)continue;let tag=tags[j]?.name;let tagCategory=tags[j]?.category;if(typeof tag==="string"&&typeof tagCategory==="string"){let fullTag="tag: "+tag.trim().toLowerCase();let fullTagCategory="tag category: "+tagCategory.trim().toLowerCase();if((jsonIsEmpty(include.categories)||include.categories[fullTagCategory]||include.categories["tag category: all"])&&!exclude.categories[fullTagCategory]&&!exclude.categories["tag category: all"]&&(jsonIsEmpty(include.tags)||include.tags[fullTag]||include.tags["tag: all"])&&!exclude.tags[fullTag]&&!exclude.tags["tag: all"]){if(varScheme.tags[fullTag]){varScheme.tags[fullTag].userScore.push(userScore);++varScheme.tags[fullTag].count}else{varScheme.tags[fullTag]={userScore:[userScore],count:1}}if(tagsMeanCount[fullTag]){++tagsMeanCount[fullTag]}else{tagsMeanCount[fullTag]=1}}}}let includedStudios={};for(let j=0;j<studios.length;j++){if(!studios[j]?.isAnimationStudio)continue;let studio=studios[j]?.name;if(typeof studio==="string"){if(includedStudios[studio])continue;includedStudios[studio]=true;let fullStudio="studio: "+studio.trim().toLowerCase();if(varScheme.studios[fullStudio]){varScheme.studios[fullStudio].userScore.push(userScore);++varScheme.studios[fullStudio].count}else{varScheme.studios[fullStudio]={userScore:[userScore],count:1}}if(studiosMeanCount[fullStudio]){++studiosMeanCount[fullStudio]}else{studiosMeanCount[fullStudio]=1}}}if(isaN(anime?.averageScore)&&includeAverageScore){averageScore.push({userScore:userScore,averageScore:anime.averageScore})}let animeYear=anime?.seasonYear||anime?.startDate?.year||anime?.endDate?.year;if(isaN(parseFloat(animeYear))&&includeYear){year.push({userScore:userScore,year:parseFloat(animeYear)})}}}if(includedUserEntryCount<1){varScheme={}}else{let genresMeanCountHigher;if(typeof sampleSize==="number"&&sampleSize>=1){genresMeanCount=sampleSize}else if(!jsonIsEmpty(genresMeanCount)){let genresCountValues=Object.values(genresMeanCount);genresCountValues=filterArrayByMeanPercentages(genresCountValues);genresMeanCount=Math.max(arrayMean(genresCountValues),arrayMode(genresCountValues));let genresMeanCountHigherValues=genresCountValues.filter(count=>count>genresMeanCount);genresMeanCountHigher=Math.max(arrayMean(genresMeanCountHigherValues),arrayMode(genresMeanCountHigherValues))}else{genresMeanCount=10}if(minSampleSize>=0){genresMeanCount=Math.max(minSampleSize,genresMeanCount)}if(typeof sampleSize==="number"&&sampleSize>=1){tagsMeanCount=sampleSize}else if(!jsonIsEmpty(tagsMeanCount)){let tagsCountValues=Object.values(tagsMeanCount);tagsCountValues=filterArrayByMeanPercentages(tagsCountValues);tagsMeanCount=Math.max(arrayMean(tagsCountValues),arrayMode(tagsCountValues))}else{tagsMeanCount=10}if(minSampleSize>=0){tagsMeanCount=Math.max(minSampleSize,tagsMeanCount)}if(typeof sampleSize==="number"&&sampleSize>=1){studiosMeanCount=sampleSize}else if(!jsonIsEmpty(studiosMeanCount)){let studiosCountValues=Object.values(studiosMeanCount);studiosMeanCount=arrayMode(studiosCountValues)}else{studiosMeanCount=10}if(minSampleSize>=0){studiosMeanCount=Math.max(minSampleSize,studiosMeanCount)}varScheme.includeUnknownVar=!contentFocused&&includeUnknownVar;varScheme.minPopularity=minPopularity;varScheme.minAverageScore=minAverageScore;let genresKey=Object.keys(varScheme.genres);let genresMean=[];for(let i=0;i<genresKey.length;i++){if(measure==="mode"){let tempModeScore=arrayMode(varScheme.genres[genresKey[i]].userScore);genresMean.push(tempModeScore)}else{let tempMeanScore=arrayMean(varScheme.genres[genresKey[i]].userScore);genresMean.push(tempMeanScore)}}genresMean=Math.max(arrayMean(genresMean),arrayMode(genresMean));for(let i=0;i<genresKey.length;i++){let originalScore;if(measure==="mode"){originalScore=arrayMode(varScheme.genres[genresKey[i]].userScore)}else{originalScore=arrayMean(varScheme.genres[genresKey[i]].userScore)}let count=varScheme.genres[genresKey[i]].count;let score=originalScore;if(count<genresMeanCountHigher){genresWithLowerCount[genresKey[i]]=true}if(contentFocused||count<genresMeanCount||count<genresMeanCountHigher&&originalScore<genresMean){if(contentFocused||count<genresMeanCount){let Cweight=count/genresMeanCount;score=score*Cweight}if(contentFocused||originalScore<genresMean){let Sweight=originalScore/genresMean;score=score*Sweight}}varScheme.genres[genresKey[i]]=score}let tagsKey=Object.keys(varScheme.tags);let tagsMean=[];for(let i=0;i<tagsKey.length;i++){if(measure==="mode"){let tempModeScore=arrayMode(varScheme.tags[tagsKey[i]].userScore);tagsMean.push(tempModeScore)}else{let tempMeanScore=arrayMean(varScheme.tags[tagsKey[i]].userScore);tagsMean.push(tempMeanScore)}}tagsMean=Math.max(arrayMean(tagsMean),arrayMode(tagsMean));for(let i=0;i<tagsKey.length;i++){let originalScore;if(measure==="mode"){originalScore=arrayMode(varScheme.tags[tagsKey[i]].userScore)}else{originalScore=arrayMean(varScheme.tags[tagsKey[i]].userScore)}let count=varScheme.tags[tagsKey[i]].count;let score=originalScore;if(contentFocused||count<tagsMeanCount||originalScore<tagsMean){if(contentFocused||count<tagsMeanCount){let Cweight=count/tagsMeanCount;score=score*Cweight}if(contentFocused||originalScore<tagsMean){let Sweight=originalScore/tagsMean;score=score*Sweight}}varScheme.tags[tagsKey[i]]=score}let studiosKey=Object.keys(varScheme.studios);let studiosMean=[];for(let i=0;i<studiosKey.length;i++){if(measure==="mode"){let tempModeScore=arrayMode(varScheme.studios[studiosKey[i]].userScore);studiosMean.push(tempModeScore)}else{let tempMeanScore=arrayMean(varScheme.studios[studiosKey[i]].userScore);studiosMean.push(tempMeanScore)}}studiosMean=arrayMean(studiosMean);for(let i=0;i<studiosKey.length;i++){let originalScore=0;if(measure==="mode"){originalScore=arrayMode(varScheme.studios[studiosKey[i]].userScore)}else{originalScore=arrayMean(varScheme.studios[studiosKey[i]].userScore)}let count=varScheme.studios[studiosKey[i]].count;if(count>=studiosMeanCount&&originalScore>=studiosMean){varScheme.studios[studiosKey[i]]=originalScore}else{delete varScheme.studios[studiosKey[i]]}}varScheme.meanGenres=genresMean;varScheme.meanTags=tagsMean;varScheme.includeCategories=include.categories;varScheme.excludeCategories=exclude.categories;varScheme.includeGenres=include.genres;varScheme.excludeGenres=exclude.genres;varScheme.includeTags=include.tags;varScheme.excludeTags=exclude.tags;if(includeYear){let yearXY=[];for(let i=0;i<year.length;i++){yearXY.push([year[i].year,year[i].userScore])}if(yearXY.length>=(minSampleSize||33)){varScheme.yearModel=linearRegression(yearXY)}}if(includeAverageScore){let averageScoreXY=[];for(let i=0;i<averageScore.length;i++){averageScoreXY.push([averageScore[i].averageScore,averageScore[i].userScore])}if(averageScoreXY.length>=(minSampleSize||33)){varScheme.averageScoreModel=linearRegression(averageScoreXY)}}}self.postMessage({status:"Processing Recommendation List"});let filters=await retrieveJSON("filters");if(filters?.["season"]){if(filters?.["season"]?.["current season"]===undefined){filters["season"]["current season"]=true}if(filters?.["season"]?.["upcoming season"]===undefined){filters["season"]["upcoming season"]=true}}let recommendedAnimeList={};let userScoreBase=100,maxScore;let meanUserScore,meanScoreAll,meanScoreAbove;let hasAnimeQuality=false;let animeEntriesArray=Object.values(animeEntries??{});let averageScoresArray=animeEntriesArray.filter(({averageScore})=>averageScore>=1).map(({averageScore})=>averageScore);let popularityArray=animeEntriesArray.filter(({popularity})=>popularity>=1).map(({popularity})=>popularity);let popularityMode=varScheme?.minPopularity?varScheme.minPopularity:arrayMode(popularityArray);let averageScoreMode=varScheme?.minAverageScore?varScheme.minAverageScore:arrayMode(averageScoresArray);let dayInMillis=1e3*60*60*24;self.postMessage({popularityMode:popularityMode,averageScoreMode:averageScoreMode});if(!jsonIsEmpty(varScheme)){let userScores=Object.values(userEntriesStatus.userScore);if(userScores?.length){let max=Math.max(...userScores);userScoreBase=max<=3?3:max<=5?5:max<=10?10:100;meanUserScore=arrayMean(userScores)}for(let i=0;i<animeEntriesArray.length;i++){self.postMessage({progress:i/animeEntriesArray.length*100*.7+30});let anime=animeEntriesArray[i];let animeID=anime?.id;let animeUrl=anime?.siteUrl;let format=anime?.format;let year=anime?.seasonYear||anime?.startDate?.year||anime?.endDate?.year;let season=anime?.season;let genres=anime?.genres||[];let tags=anime?.tags||[];let studios=(anime?.studios?.nodes?.every(studio=>!studio?.isAnimationStudio)&&anime?.studios?.nodes?.length?[anime?.studios?.nodes?.[0]]:anime?.studios?.nodes?.filter(studio=>studio?.isAnimationStudio))||[];studios=studios?.length&&studios instanceof Array?studios:[];let staffs=anime?.staff?.edges||[];let status=anime?.status;let popularity=anime?.popularity;let userStatus="UNWATCHED";if(typeof userEntriesStatus?.userStatus?.[animeID]==="string"){userStatus=userEntriesStatus.userStatus[animeID];let tmpUserStatus=userStatus.trim().toLowerCase();if(filters?.["user status"]&&filters?.["user status"]?.[tmpUserStatus]===undefined){filters["user status"][tmpUserStatus]=true}}if(typeof season==="string"){let tempSeason=season.trim().toLowerCase();if(filters?.["season"]&&filters?.["season"]?.[tempSeason]===undefined){filters["season"][tempSeason]=true}}if(typeof status==="string"){let tempStatus=status.trim().toLowerCase();if(filters?.["airing status"]&&filters?.["airing status"]?.[tempStatus]===undefined){filters["airing status"][tempStatus]=true}}if(typeof format==="string"){let tempFormat=format.trim().toLowerCase();if(filters?.["format"]&&filters?.["format"]?.[tempFormat]===undefined){filters["format"][tempFormat]=true}}if(year){let tempYear=year?.toString?.().trim().toLowerCase();if(filters?.["year"]&&filters?.["year"]?.[tempYear]===undefined){filters["year"][tempYear]=true}}let genresIncluded={};let tagsIncluded={};let studiosIncluded={};let zgenres=[];for(let j=0;j<genres.length;j++){let genre=genres[j];if(typeof genre!=="string")continue;genre=genre.trim().toLowerCase();let fullGenre="genre: "+genre;if((jsonIsEmpty(varScheme.includeGenres)||varScheme.includeGenres[fullGenre]||varScheme.includeGenres["genre: all"])&&!varScheme.excludeGenres[fullGenre]&&!varScheme.excludeGenres["genre: all"]){if(typeof varScheme.genres[fullGenre]==="number"){zgenres.push({genre:fullGenre,score:varScheme.genres[fullGenre]});if(typeof varScheme.meanGenres==="number"&&varScheme.genres[fullGenre]>=varScheme.meanGenres&&!genresIncluded[genre]){let tmpscore=varScheme.genres[fullGenre];genresIncluded[genre]=tmpscore}}else if(typeof varScheme.meanGenres==="number"&&varScheme.includeUnknownVar){zgenres.push({genre:fullGenre,score:varScheme.meanGenres})}}if(filters?.["genre"]&&filters?.["genre"]?.[genre]===undefined){filters["genre"][genre]=true}}let ztags=[];for(let j=0;j<tags.length;j++){let tag=tags[j]?.name;if(typeof tag!=="string")continue;let tagCategory=tags[j]?.category;if(typeof tagCategory!=="string")continue;let tagRank=tags[j]?.rank;tag=tag.trim().toLowerCase();let fullTag="tag: "+tag;tagCategory=tagCategory.trim().toLowerCase();let fullTagCategory="tag category: "+tagCategory;if((jsonIsEmpty(varScheme.includeCategories)||varScheme.includeCategories[fullTagCategory]||varScheme.includeCategories["tag category: all"])&&!varScheme.excludeCategories[fullTagCategory]&&!varScheme.excludeCategories["tag category: all"]&&(jsonIsEmpty(varScheme.includeTags)||varScheme.includeTags[fullTag]||varScheme.includeTags["tag: all"])&&!varScheme.excludeTags[fullTag]&&!varScheme.excludeTags["tag: all"]){if(typeof varScheme.tags[fullTag]==="number"&&typeof tagRank==="number"){if(tagRank>=tagRankLimit){ztags.push(varScheme.tags[fullTag])}if(typeof varScheme.meanTags==="number"&&varScheme.tags[fullTag]>=varScheme.meanTags&&!tagsIncluded[tag]){let tmpscore=varScheme.tags[fullTag];tagsIncluded[tag]=tmpscore}}else if(typeof varScheme.meanTags==="number"&&varScheme.includeUnknownVar){ztags.push(varScheme.meanTags)}}if(filters?.["tag"]&&filters?.["tag"]?.[tag]===undefined){filters["tag"][tag]=true}if(filters?.["tag category"]&&filters?.["tag category"]?.[tagCategory]===undefined){filters["tag category"][tagCategory]=true}}let includedStudios={};for(let j=0;j<studios.length;j++){let studio=studios[j]?.name;if(typeof studio!=="string")continue;if(includedStudios[studio])continue;includedStudios[studio]=true;studio=studio.trim().toLowerCase();let fullStudio="studio: "+studio;if(typeof varScheme.studios[fullStudio]==="number"){if(!studiosIncluded[studio]){let tmpscore=varScheme.studios[fullStudio];studiosIncluded[studio]=tmpscore}}if(filters?.["studio"]&&filters?.["studio"]?.[studio]===undefined){filters["studio"][studio]=true}}for(let j=0;j<staffs.length;j++){let staffRole=staffs[j]?.role;if(typeof staffRole!=="string")continue;staffRole=staffRole.split("(")[0].trim().toLowerCase();if(filters?.["staff role"]&&filters?.["staff role"]?.[staffRole]===undefined){filters["staff role"][staffRole]=true}}let animeQuality=[];let yearModel=varScheme.yearModel??{};if(isaN(year)&&!jsonIsEmpty(yearModel)&&includeYear&&yearModel?.slope>0){let seasonYear=year;if(typeof seasonYear==="string"){seasonYear=parseFloat(seasonYear)}let modelScore=LRpredict(yearModel,seasonYear);if(modelScore>=1){animeQuality.push(modelScore)}else{animeQuality.push(1)}}else{animeQuality.push(1)}let averageScore=anime?.averageScore;let averageScoreModel=varScheme.averageScoreModel??{};if(isaN(averageScore)&&!jsonIsEmpty(averageScoreModel)&&includeAverageScore&&averageScoreModel?.slope>0){if(typeof averageScore==="string"){averageScore=parseFloat(averageScore)}let modelScore=LRpredict(averageScoreModel,averageScore);if(modelScore>=1){animeQuality.push(modelScore)}else{animeQuality.push(1)}}else{animeQuality.push(1)}let episodes=anime?.episodes;let duration=anime?.duration;let animeContent=[];if(zgenres.length){let genreValues=zgenres.reduce((acc,_genre)=>{acc.push(_genre.score);return acc},[]);if(zgenres.some(e=>genresWithLowerCount[e.genre])){if(measure==="mode"){animeContent.push(arrayMode(genreValues))}else{animeContent.push(arrayMean(genreValues))}}else{animeContent.push(Math.max(...genreValues))}}else{animeContent.push(1)}if(ztags.length){if(measure==="mode"){animeContent.push(arrayMode(ztags))}else{animeContent.push(arrayMean(ztags))}}else{animeContent.push(1)}let finalAnimeQuality=animeQuality.length?measure==="mode"?arrayMode(animeQuality):arrayMean(animeQuality):1;let finalAnimeContent=animeContent.length?measure==="mode"?arrayMode(animeContent):arrayMean(animeContent):1;let score=finalAnimeContent*finalAnimeQuality;if(hasAnimeQuality!==true){if(finalAnimeQuality>0){maxScore=Math.pow(userScoreBase,2);hasAnimeQuality=true}else if(hasAnimeQuality===undefined){maxScore=userScoreBase}}genres=genres.length?genres:[];tags=tags.length?tags.map(e=>{return{name:e?.name,rank:e?.rank}}):[];studios=studios.reduce((result,e)=>Object.assign(result,{[formatCustomString(e?.name)]:e?.siteUrl}),{});let weightedScore;if(averageScore>0){if(score>0&&averageScore<averageScoreMode){let ASweight=averageScore/averageScoreMode;weightedScore=score*ASweight}else{weightedScore=score}}let newScore=weightedScore!==score?weightedScore:score;if(popularity>0&&popularityMode>0){if(newScore>0&&popularity<popularityMode){let PSweight=popularity/popularityMode;weightedScore=score*PSweight}else{weightedScore=newScore}}if(!weightedScore||weightedScore<=0||!isFinite(weightedScore)){weightedScore=1}if(!score||score<=0||!isFinite(score)){score=1}if(typeof anime?.nextAiringEpisode?.episode==="number"&&!isNaN(anime?.nextAiringEpisode?.episode)&&typeof anime?.nextAiringEpisode?.airingAt==="number"&&!isNaN(anime?.nextAiringEpisode?.airingAt)){let airingAt=anime?.nextAiringEpisode?.airingAt;if(anime?.nextAiringEpisode?.episode===episodes){let airingAtDate=new Date(airingAt*1e3);let currentDate=new Date;if(airingAtDate<=currentDate){anime.nextAiringEpisode=null;status="FINISHED"}else if(airingAtDate>currentDate){self.postMessage({animeCompletionAiringAt:anime?.nextAiringEpisode?.airingAt})}}if(isJsonObject(anime.nextAiringEpisode)){let _title=anime?.title?.english||anime?.title?.userPreferred||anime?.title?.romaji||anime?.title?.native;let _releaseEpisode=anime?.nextAiringEpisode?.episode;let _releaseDateMillis=airingAt*1e3;let _imageURL=anime?.coverImage?.large||"";if((!equalsNCS(userStatus,"UNWATCHED")||weightedScore>1)&&typeof _releaseDateMillis==="number"&&_releaseDateMillis>=(new Date).getTime()-dayInMillis){self.postMessage({animeReleaseNotification:{id:animeID,title:_title,releaseEpisodes:_releaseEpisode,maxEpisode:typeof episodes==="number"?episodes:-1,releaseDateMillis:_releaseDateMillis,imageURL:typeof _imageURL==="string"?_imageURL:"",isMyAnime:userStatus!=="UNWATCHED"}})}}}else if(jsonIsEmpty(anime.nextAiringEpisode)&&!(ncsCompare(status,"finished")||ncsCompare(status,"cancelled"))&&year){let{month,day}=anime?.startDate||{};if(parseInt(month)>0){month=parseInt(month)-1}let possibleAiringDate=getJapaneseStartDate({season:season,year:year,month:month,day:day});if(possibleAiringDate&&possibleAiringDate>new Date){anime.nextAiringEpisode={airingAt:Math.floor(possibleAiringDate.getTime()/1e3),episode:1}}}let favoriteContents={genres:genresIncluded,tags:tagsIncluded,studios:studiosIncluded};recommendedAnimeList[animeID]={id:animeID,title:anime?.title,animeUrl:animeUrl,userScore:userEntriesStatus?.userScore?.[animeID],animeRelations:anime?.relations?.edges,averageScore:averageScore,popularity:popularity,trending:anime?.trending,favorites:anime?.favourites,score:score,weightedScore:weightedScore,favoriteContents:favoriteContents,userStatus:formatCustomString(userStatus),status:formatCustomString(status),description:anime?.description,genres:genres.map(e=>formatCustomString(e)),tags:tags.map(e=>formatCustomString(e)),dateAdded:anime?.dateAdded,dateEdited:anime?.dateEdited,startDate:anime?.startDate,year:year,season:formatCustomString(season),format:formatCustomString(format),studios:studios,episodes:episodes,duration:duration,coverImageUrl:anime?.coverImage?.large,trailerID:anime?.trailer?.id,bannerImageUrl:anime?.bannerImage,trailerThumbnailUrl:anime?.trailer?.thumbnail,nextAiringEpisode:anime?.nextAiringEpisode}}}else{for(let i=0;i<animeEntriesArray.length;i++){self.postMessage({progress:i/animeEntriesArray.length*100});let anime=animeEntriesArray[i];let animeID=anime?.id;let animeUrl=anime?.siteUrl;let format=anime?.format;let year=anime?.seasonYear||anime?.startDate?.year||anime?.endDate?.year;let season=anime?.season;let genres=anime?.genres||[];let tags=anime?.tags||[];let studios=anime?.studios?.nodes?.every(studio=>!studio?.isAnimationStudio)&&anime?.studios?.nodes?.length?[anime?.studios?.nodes?.[0]]:anime?.studios?.nodes?.filter(studio=>studio?.isAnimationStudio);studios=studios?.length&&studios instanceof Array?studios:[];let staffs=anime?.staff?.edges||[];let status=anime?.status;let episodes=anime?.episodes;let duration=anime?.duration;if(typeof season==="string"){let tempSeason=season.trim().toLowerCase();if(filters?.["season"]&&filters?.["season"]?.[tempSeason]===undefined){filters["season"][tempSeason]=true}}if(typeof status==="string"){let tempStatus=status.trim().toLowerCase();if(filters?.["airing status"]&&filters?.["airing status"]?.[tempStatus]===undefined){filters["airing status"][tempStatus]=true}}if(typeof format==="string"){let tempFormat=format.trim().toLowerCase();if(filters?.["format"]&&filters?.["format"]?.[tempFormat]===undefined){filters["format"][tempFormat]=true}}if(year){let tempYear=year?.toString?.().trim().toLowerCase();if(filters?.["year"]&&filters?.["year"]?.[tempYear]===undefined){filters["year"][tempYear]=true}}for(let j=0;j<genres.length;j++){let genre=genres[j];if(typeof genre!=="string")continue;genre=genre.trim().toLowerCase();if(filters?.["genre"]&&filters?.["genre"]?.[genre]===undefined){filters["genre"][genre]=true}}for(let j=0;j<tags.length;j++){let tag=tags[j]?.name;if(typeof tag!=="string")continue;tag=tag.trim().toLowerCase();if(filters?.["tag"]&&filters?.["tag"]?.[tag]===undefined){filters["tag"][tag]=true}let tagCategory=tags[j]?.category;if(typeof tagCategory!=="string")continue;tagCategory=tagCategory.trim().toLowerCase();if(filters?.["tag category"]&&filters?.["tag category"]?.[tagCategory]===undefined){filters["tag category"][tagCategory]=true}}for(let j=0;j<studios.length;j++){let studio=studios[j]?.name;if(typeof studio!=="string")continue;studio=studio.trim().toLowerCase();if(filters?.["studio"]&&filters?.["studio"]?.[studio]===undefined){filters["studio"][studio]=true}}for(let j=0;j<staffs.length;j++){let staffRole=staffs[j].role;if(typeof staffRole!=="string")continue;staffRole=staffRole.split("(")[0].trim().toLowerCase();if(filters?.["staff role"]&&filters?.["staff role"]?.[staffRole]===undefined){filters["staff role"][staffRole]=true}}let score=1;let averageScore=anime?.averageScore;if(isaN(averageScore)){if(typeof averageScore==="string"){averageScore=parseFloat(averageScore)}}let favourites=anime?.favourites;if(isaN(favourites)){if(typeof favourites==="string"){favourites=parseFloat(favourites)}}let popularity=anime?.popularity;if(isaN(popularity)){if(typeof popularity==="string"){popularity=parseFloat(popularity)}}if(isaN(averageScore)&&isaN(favourites)&&isaN(popularity)&&popularity){let favPopRatio=1;if(anime.favourites<anime.popularity){favPopRatio=anime.favourites/anime.popularity}score=favPopRatio*averageScore}maxScore=100;genres=genres.length?genres:[];tags=tags.length?tags.map(e=>{return{name:e?.name,rank:e?.rank}}):[];studios=studios.reduce((result,e)=>Object.assign(result,{[formatCustomString(e?.name)]:e?.siteUrl}),{});let weightedScore;if(averageScore>0){if(score>0&&averageScore<averageScoreMode){let ASweight=averageScore/averageScoreMode;weightedScore=score*ASweight}else{weightedScore=score}}let newScore=weightedScore!==score?weightedScore:score;if(popularity>0&&popularityMode>0){if(newScore>0&&popularity<popularityMode){let PSweight=popularity/popularityMode;weightedScore=score*PSweight}else{weightedScore=newScore}}if(!weightedScore||weightedScore<=0||!isFinite(weightedScore)){weightedScore=1}if(!score||score<=0||!isFinite(score)){score=1}if(typeof anime?.nextAiringEpisode?.episode==="number"&&!isNaN(anime?.nextAiringEpisode?.episode)&&typeof anime?.nextAiringEpisode?.airingAt==="number"&&!isNaN(anime?.nextAiringEpisode?.airingAt)){let airingAt=anime?.nextAiringEpisode?.airingAt;if(anime?.nextAiringEpisode?.episode===episodes){let airingAtDate=new Date(airingAt*1e3);let currentDate=new Date;if(airingAtDate<=currentDate){anime.nextAiringEpisode=null;status="FINISHED"}else if(airingAtDate>currentDate){self.postMessage({animeCompletionAiringAt:anime?.nextAiringEpisode?.airingAt})}}if(isJsonObject(anime.nextAiringEpisode)){let _title=anime?.title?.english||anime?.title?.userPreferred||anime?.title?.romaji||anime?.title?.native;let _releaseEpisode=anime?.nextAiringEpisode?.episode;let _releaseDateMillis=airingAt*1e3;let _imageURL=anime?.coverImage?.large||"";if(weightedScore>1&&typeof _releaseDateMillis==="number"&&_releaseDateMillis>=(new Date).getTime()-dayInMillis){self.postMessage({animeReleaseNotification:{id:animeID,title:_title,releaseEpisodes:_releaseEpisode,maxEpisode:typeof episodes==="number"?episodes:-1,releaseDateMillis:_releaseDateMillis,imageURL:typeof _imageURL==="string"?_imageURL:"",isMyAnime:false}})}}}else if(jsonIsEmpty(anime.nextAiringEpisode)&&!(ncsCompare(status,"finished")||ncsCompare(status,"cancelled"))&&year){let{month,day}=anime?.startDate||{};if(parseInt(month)>0){month=parseInt(month)-1}let possibleAiringDate=getJapaneseStartDate({season:season,year:year,month:month,day:day});if(possibleAiringDate&&possibleAiringDate>new Date){anime.nextAiringEpisode={airingAt:Math.floor(possibleAiringDate.getTime()/1e3),episode:1}}}recommendedAnimeList[animeID]={id:animeID,title:anime?.title,animeUrl:animeUrl,userScore:userEntriesStatus?.userScore?.[animeID],animeRelations:anime?.relations?.edges,averageScore:averageScore,popularity:popularity,trending:anime?.trending,favorites:anime?.favourites,score:score,weightedScore:weightedScore,userStatus:"UNWATCHED",status:formatCustomString(status),description:anime?.description,genres:genres.map(e=>formatCustomString(e)),tags:tags.map(e=>formatCustomString(e)),dateAdded:anime?.dateAdded,dateEdited:anime?.dateEdited,startDate:anime?.startDate,year:year,season:formatCustomString(season),format:formatCustomString(format),studios:studios,episodes:episodes,duration:duration,coverImageUrl:anime?.coverImage?.large,trailerID:anime?.trailer?.id,bannerImageUrl:anime?.bannerImage,trailerThumbnailUrl:anime?.trailer?.thumbnail,nextAiringEpisode:anime?.nextAiringEpisode}}}let userAnimes=[];let recommendedAnimeListEntries=Object.values(recommendedAnimeList);let userScoresAnimes=[],scoresArray=[],scoreAboveMeanArray=[];recommendedAnimeListEntries=recommendedAnimeListEntries.map(anime=>{let originalHighestRange,originalScore;if(customUserScoreBase>=0){originalHighestRange=userScoreBase;originalScore=originalHighestRange>1?mapValue(anime.score,1,maxScore,1,originalHighestRange):anime.score}let newHighestRange=customUserScoreBase>=0?customUserScoreBase:userScoreBase;anime.score=newHighestRange>1?mapValue(anime.score,1,maxScore,1,newHighestRange):anime.score;anime.weightedScore=newHighestRange>1?mapValue(anime.weightedScore,1,maxScore,1,newHighestRange):anime.weightedScore;if(anime.userScore!=null&&anime.userScore>=1){if(anime.userScore>=meanUserScore){scoreAboveMeanArray.push(anime.score)}userScoresAnimes.push(anime);userAnimes.push({userScore:anime.userScore,score:originalScore===undefined?anime.score:originalScore||anime.score})}scoresArray.push(anime.score);return anime});if(scoresArray?.length){meanScoreAll=arrayMean(scoresArray)}if(scoreAboveMeanArray?.length){meanScoreAbove=arrayMean(scoreAboveMeanArray)}recommendedAnimeListEntries.forEach(anime=>{let animeID=anime.id;if(animeID!==null&&animeID!==undefined){anime.meanScoreAll=meanScoreAll>=1?meanScoreAll:1;anime.meanScoreAbove=meanScoreAbove>=1?meanScoreAbove:1;recommendedAnimeList[animeID]=anime}});await saveJSON(Object.values(recommendedAnimeList)||[],"recommendedAnimeList");await saveJSON(filters,"filters");let recListMAE=calculateMAE(userAnimes.map(({userScore})=>userScore),userAnimes.map(({score})=>score));if(recListMAE!=null){await saveJSON(recListMAE,"recListMAE");self.postMessage({recListMAE:recListMAE})}await saveJSON(true,"shouldLoadAnime");await saveJSON(false,"shouldProcessRecommendation");self.postMessage({status:null});self.postMessage({progress:100});self.postMessage({message:"success",hasPassedFilters:data?.hasPassedFilters})}catch(err){console.error(err);self.postMessage({error:true})}};function formatCustomString(str){if(typeof str==="string"){str=str!=="_"?str.replace(/\_/g," "):str;str=str!=='\\"'?str.replace(/\\"/g,'"'):str;str=str.replace(/\b(tv|ona|ova)\b/gi,match=>match.toUpperCase())}return str}function jsonIsEmpty(obj){for(const key in obj){return false}return true}function equalsNCS(str1,str2){let s1=str1;let s2=str2;if(typeof s1==="number")s1=s1.toString();if(typeof s2==="number")s2=s2.toString();if(typeof s1==="string")s1=s1.trim().toLowerCase();if(typeof s2==="string")s2=s2.trim().toLowerCase();return s1===s2}function isaN(num){if(!num&&num!==0){return false}else if(typeof num==="boolean"){return false}else if(typeof num==="string"&&!num){return false}return!isNaN(num)}function isJson(j){try{return j?.constructor.name==="Object"&&`${j}`==="[object Object]"}catch(e){return false}}function mapValue(originalValue,lowestValue,highestValue,newLowestRange,newHighestRange){let mappedValue=(originalValue-lowestValue)*(newHighestRange-newLowestRange)/(highestValue-lowestValue)+newLowestRange;return mappedValue}function arrayMean(obj){return arraySum(obj)/obj.length||0}function arraySum(obj){return obj.reduce((a,b)=>a+b,0)}function arrayMedian(arr){const sortedArr=arr.slice().sort((a,b)=>a-b);const n=sortedArr.length;if(n%2===0){const middleRight=n/2;const middleLeft=middleRight-1;return(sortedArr[middleLeft]+sortedArr[middleRight])/2}else{const middle=Math.floor(n/2);return sortedArr[middle]}}function arrayMode(obj){if(obj.length===0){return}else if(obj.length===1){return obj[0]}else if(obj.length===2){return(obj[0]+obj[1])/2}let max=parseFloat(Math.max(...obj));let min=parseFloat(Math.min(...obj));const boundary=1-6e-17!==1?6e-17:1e-16;let classW=parseFloat((max-min)/(1+3.322*Math.log(obj.length)));let classIs=[];if(max===min||classW<boundary){classIs=[{low:min,high:max,freq:0}]}else{let high=min+classW-boundary,low=min;classIs=[{low:low,high:high,freq:0}];while(classIs.slice(-1)[0].high<max){low=high+boundary;high=low+classW-boundary;classIs.push({low:low,high:high,freq:0})}}for(let i=0;i<obj.length;i++){for(let j=0;j<classIs.length;j++){let num=obj[i];if(num>=classIs[j].low&&num<=classIs[j].high){++classIs[j].freq;continue}}}let modeClass=classIs[0];let modeIdx=0;for(let i=1;i<classIs.length;i++){if(classIs[i].freq>modeClass.freq){modeClass=classIs[i];modeIdx=i}}let modLowLim=modeClass.low;let modFreq=modeClass.freq;let modPreFreq=!classIs[modeIdx-1]?0:classIs[modeIdx-1].freq;let modSucFreq=!classIs[modeIdx+1]?0:classIs[modeIdx+1].freq;return modLowLim+(modFreq-modPreFreq)/(2*modFreq-modPreFreq-modSucFreq)*classW}function arrayProbability(obj){if(!obj?.length)return 0;return obj.reduce((a,b)=>a*b,1)}function filterArrayByMeanPercentages(numbers){const counts={};numbers.forEach(num=>{counts[num]=counts[num]?counts[num]+1:1});const percentages={};Object.keys(counts).forEach(key=>{percentages[key]=counts[key]/numbers.length});const CTPercentage=arrayMean(Object.values(percentages));return numbers.filter(num=>{return percentages[num]<=CTPercentage})}function linearRegression(XY){let lr={};let n=XY.length;let sum_x=0;let sum_y=0;let sum_xy=0;let sum_xx=0;let sum_yy=0;for(let i=0;i<XY.length;i++){sum_x+=XY[i][0];sum_y+=XY[i][1];sum_xy+=XY[i][0]*XY[i][1];sum_xx+=XY[i][0]*XY[i][0];sum_yy+=XY[i][1]*XY[i][1]}lr["slope"]=(n*sum_xy-sum_x*sum_y)/(n*sum_xx-sum_x*sum_x);lr["intercept"]=(sum_y-lr.slope*sum_x)/n;lr["r2"]=Math.pow((n*sum_xy-sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);return lr}function LRpredict(modelObj,x){if(!modelObj)return null;if(!modelObj.slope||!modelObj.intercept)return null;if(isNaN(modelObj.slope)||isNaN(modelObj.intercept))return null;return parseFloat(modelObj.slope)*x+parseFloat(modelObj.intercept)}function LRpredictInverse(modelObj,y){if(!modelObj)return null;if(!modelObj.slope||!modelObj.intercept)return null;if(isNaN(modelObj.slope)||isNaN(modelObj.intercept))return null;if(parseFloat(modelObj.slope)===0)return null;return(parseFloat(y)-parseFloat(modelObj.intercept))/parseFloat(modelObj.slope)}function calculateMAE(predictions,actualValues){let sum=0;for(let i=0;i<predictions?.length;i++){sum+=Math.abs(predictions[i]-actualValues[i])}return Math.abs(sum/predictions?.length)||null}function isJsonObject(obj){return Object.prototype.toString.call(obj)==="[object Object]"}async function IDBinit(){return await new Promise(resolve=>{request=indexedDB.open("Kanshi.Anime.Recommendations.Anilist.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onerror=error=>{console.error(error)};request.onsuccess=event=>{db=event.target.result;return resolve()};request.onupgradeneeded=event=>{db=event.target.result;db.createObjectStore("MyObjectStore");let transaction=event.target.transaction;transaction.oncomplete=()=>{return resolve()}}})}async function saveJSON(data,name){return await new Promise(async(resolve,reject)=>{try{let write=db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").openCursor();write.onsuccess=async event=>{let put=await db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").put(data,name);put.onsuccess=event=>{return resolve()};put.onerror=event=>{return resolve()}};write.onerror=async error=>{console.error(error);return reject()}}catch(ex){console.error(ex)}})}async function retrieveJSON(name){return await new Promise(resolve=>{try{let read=db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").get(name);read.onsuccess=()=>{return resolve(read.result)};read.onerror=error=>{console.error(error);return resolve()}}catch(ex){console.error(ex);return resolve()}})}function getJapaneseStartDate({season,year,month,day}){if(parseInt(year)>=0){if(parseInt(month)>=0){return new Date(parseInt(year),parseInt(month),parseInt(day||1)||1)}const seasonKey=season?.trim()?.toLowerCase?.();if(["winter","spring","summer","fall"].includes(seasonKey)&&!isNaN(year)){let seasons={winter:new Date(parseInt(year),0,1),spring:new Date(parseInt(year),3,1),summer:new Date(parseInt(year),6,1),fall:new Date(parseInt(year),9,1)};return seasons[seasonKey]}return new Date(parseInt(year),0,1)}else{return null}}function ncsCompare(str1,str2){try{if(typeof str1!=="string"||typeof str2!=="string"){return false}return str1.trim().toLowerCase()===str2.trim().toLowerCase()}catch(e){}}