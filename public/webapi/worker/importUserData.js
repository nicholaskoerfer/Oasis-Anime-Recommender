let request,db;self.onmessage=async({data})=>{if(!db){await IDBinit()}self.postMessage({status:"Importing User Data"});const reader=new FileReader;reader.onload=async()=>{let fileContent;try{self.postMessage({progress:0});self.postMessage({progress:30});fileContent=JSON.parse(reader.result);self.postMessage({progress:75})}catch(e){fileContent=undefined}try{if(!fileContent){self.postMessage({progress:0});fileContent=await parseAsync(reader.result,true).value;self.postMessage({progress:75})}if(!fileContent){self.postMessage({status:"File parsing has failed"});self.postMessage({error:"File parsing has failed"});return}let hasImportedData;await saveJSON(true,"shouldProcessRecommendation");const userData=fileContent?.userData;const username=userData?.username??fileContent?.username;const shouldImportUserEntries=username&&typeof username=="string";if(shouldImportUserEntries){self.postMessage({importedUsername:username})}self.postMessage({progress:76.10993657505286});const tagInfo=fileContent.tagInfo?new Date(fileContent.tagInfo):null;if(isJsonObject(tagInfo)&&!jsonIsEmpty(tagInfo)){await saveJSON(tagInfo,"tagInfo");hasImportedData=true}self.postMessage({progress:81.60676532769556});if(shouldImportUserEntries){const userEntries=userData?.userEntries;if(userEntries instanceof Array){await saveJSON({username:username,userEntries:userEntries},"userData");await saveJSON(fileContent.userAnimeUpdateAt,"userAnimeUpdateAt");hasImportedData=true}}const algorithmFilters=fileContent.algorithmFilters;if(algorithmFilters instanceof Array&&algorithmFilters?.length>0){self.postMessage({algorithmFilters:algorithmFilters});await saveJSON(algorithmFilters,"algorithmFilters");hasImportedData=true}self.postMessage({progress:82.87526427061312});const userList=fileContent.userList;const hiddenEntries=userList?.hiddenEntries;const categories=userList?.categories;const selectedCategory=userList?.selectedCategory;const animeCautions=userList?.animeCautions;const category=categories?.[selectedCategory];if(isJsonObject(hiddenEntries)&&typeof selectedCategory==="string"&&animeCautions instanceof Array&&category?.animeFilters instanceof Array&&category?.animeList instanceof Array&&typeof category?.isHiddenList==="boolean"&&typeof category?.sortBy?.sortName==="string"&&typeof category?.sortBy?.sortType==="string"){self.postMessage({animeCautions:animeCautions});self.postMessage({importedHiddenEntries:hiddenEntries});await saveJSON(userList,"userList");hasImportedData=true}self.postMessage({progress:94.08033826638479});const animeEntries=fileContent.animeEntries;const excludedEntries=fileContent.excludedEntries;const entriesVersion=fileContent.entriesVersion;let animeUpdateAt=fileContent.animeUpdateAt||1706674120;let currentAnimeUpdateAt=await retrieveJSON("animeUpdateAt")||1706674120;let shouldImportAniEntries=animeUpdateAt>currentAnimeUpdateAt&&animeUpdateAt&&isJsonObject(animeEntries)&&!jsonIsEmpty(animeEntries)||entriesVersion&&entriesVersion>(await retrieveJSON("entriesVersion")??0)||Object.keys(await retrieveJSON("animeEntries")||{}).length<Object.keys(fileContent.animeEntries||{}).length;if(shouldImportAniEntries){await saveJSON(animeEntries,"animeEntries");await saveJSON(excludedEntries,"excludedEntries");await saveJSON(entriesVersion,"entriesVersion");await saveJSON(animeUpdateAt,"animeUpdateAt");hasImportedData=true}await saveJSON(true,"shouldProcessRecommendation");if(hasImportedData){self.postMessage({status:"Data has been Imported"});self.postMessage({status:null});self.postMessage({progress:100});self.postMessage({message:"success"})}else{self.postMessage({status:typeof error==="string"?error:"Something went wrong"});self.postMessage({status:null});self.postMessage({progress:100});self.postMessage({error:"Something went wrong"})}}catch(error){console.error(error);self.postMessage({status:typeof error==="string"?error:"Something went wrong"});self.postMessage({progress:100});self.postMessage({error:error})}};reader.onerror=error=>{console.error(error);self.postMessage({status:typeof error==="string"?error:"Something went wrong"});self.postMessage({progress:100});self.postMessage({error:error})};if(reader.readyState!==1){reader.readAsText(data.importedFile)}else{reader.onabort=()=>{reader.readAsText(data.importedFile)};reader.abort()}};function isJsonObject(obj){return Object.prototype.toString.call(obj)==="[object Object]"}function jsonIsEmpty(obj){for(const key in obj){return false}return true}async function IDBinit(){return await new Promise(resolve=>{let request=indexedDB.open("Kanshi.Anime.Recommendations.Anilist.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onerror=error=>{console.error(error)};request.onsuccess=event=>{db=event.target.result;return resolve()};request.onupgradeneeded=event=>{db=event.target.result;db.createObjectStore("MyObjectStore");let transaction=event.target.transaction;transaction.oncomplete=()=>{return resolve()}}})}async function saveJSON(data,name){return await new Promise(async(resolve,reject)=>{try{let write=db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").openCursor();write.onsuccess=async event=>{let put=await db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").put(data,name);put.onsuccess=event=>{return resolve()};put.onerror=event=>{return resolve()}};write.onerror=async error=>{console.error(error);return reject()}}catch(ex){console.error(ex)}})}async function retrieveJSON(name){return await new Promise(resolve=>{try{let read=db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").get(name);read.onsuccess=()=>{return resolve(read.result)};read.onerror=error=>{console.error(error);return resolve()}}catch(ex){console.error(ex);return resolve()}})}function isValidJson(j){let construct=j?.constructor.name;try{return construct==="Object"&&`${j}`==="[object Object]"||j instanceof Array||construct==="Array"}catch(e){return false}}function jsonIsEmpty(obj){for(const key in obj){return false}return true}function parseAsync(text,isDone=true){if(isValidJson(text)){return text}else if(!(typeof text==="string"||text instanceof String)){throw new Error(`Input Text has Unexpected Type of ${text?.constructor?.name||typeof text}`,{cause:JSON.stringify(text)})}let streamDone=isDone,wait={},textLength=streamDone?text.length:0;return{value:new Promise(async resolve=>{let at=0;let ch="";let textProcessed=0;let chunkProcessed=0;let seek=async keepCurrentCharacter=>{ch=text.charAt(at);if(keepCurrentCharacter&&!(ch&&ch<=" "))return;if(!streamDone&&!ch){if(wait?.promise){await wait.promise}else{wait.promise=new Promise(resolve=>{wait.resolve=resolve});await wait.promise}wait={};return await seek(keepCurrentCharacter)}else{if(ch){++chunkProcessed;++textProcessed;++at}ch=text.charAt(at);while(ch&&ch<=" "){++chunkProcessed;++textProcessed;ch=text.charAt(++at)}if(!ch){if(!streamDone){return await seek(keepCurrentCharacter)}}}};let wordCheck=async()=>{let word="";do{word+=ch;await seek()}while(ch.match(/[a-z]/i));return word};let normalizeUnicodedString=async(quote,isObject)=>{let inQuotes="";let startStringIndex=at;let lastEndQuoteIndex=startStringIndex-1;let endQuoteIndex=0;let slashCount=0;while(quote){endQuoteIndex=text.indexOf(quote,lastEndQuoteIndex+1);if(endQuoteIndex<0){if(streamDone)break;if(wait?.promise){await wait.promise}else{wait.promise=new Promise(resolve=>{wait.resolve=resolve});await wait.promise}wait={};return await normalizeUnicodedString(quote)}lastEndQuoteIndex=endQuoteIndex;ch=text.charAt(lastEndQuoteIndex-1);while(ch==="\\"){slashCount++;ch=text.charAt(lastEndQuoteIndex-(slashCount+1))}if(slashCount%2!==0){slashCount=0}else{inQuotes=text.substring(startStringIndex,endQuoteIndex);const newText=text.slice(endQuoteIndex+1);if(!isObject){const trimmedText=newText.trim();if(trimmedText!==""){text=(quote+text).match(/[^ ]* *[^ ]*/)[0];at=text.length-1;throw error("Unexpected non-whitespace character after JSON")}}text=newText;at=0;break}}if(endQuoteIndex>0){if(inQuotes){let stringifiedValue=`"${inQuotes}"`;return JSON.parse(stringifiedValue)}else if(endQuoteIndex>0){return""}}else{throw error("Unterminated string in JSON")}};let error=message=>{return new Error(`${message} at position ${at}`,{cause:JSON.stringify(text)})};let isObject;async function parseAsync(){const byteSize=64*1024;if(chunkProcessed>=byteSize){chunkProcessed=0;let progress=textProcessed/textLength*100*.75;self.postMessage({progress:progress});if(progress>.01){self.postMessage({status:`${progress.toFixed(2)}% Importing User Data`})}}await seek(true);let quote;let wordToFind;let isFirstKey;switch(ch){case"{":isObject=true;let returnObj={};text=text.slice(at+1);at=0;await seek(true);if(ch==="}"){text=text.slice(at+1);at=0;return returnObj}else if(ch!==`"`&&ch!==`'`&&ch!=="`"){throw error("Expected property name or '}' in JSON")}isFirstKey=true;let lastCh;do{if(isFirstKey){isFirstKey=false}else if(ch===","){lastCh=ch;text=text.slice(at+1);at=0;await seek(true)}let key=await parseAsync();await seek(true);if(ch===":"){lastCh=ch;text=text.slice(at+1);at=0;await seek(true)}else{throw error("Expected ':' after property name in JSON")}returnObj[key]=await parseAsync();await seek(true);if(ch==="}"){text=text.slice(at+1);at=0;return returnObj}}while(ch===",");if(lastCh===","){throw error("Expected double-quoted property name in JSON")}else if(lastCh===":"){throw error("Unexpected end of JSON input")}else if(jsonIsEmpty(returnObj)){throw error("Expected property name or '}' in JSON")}else{throw error("Expected ',' or '}' after property value in JSON")}case"[":isObject=true;let returnArr=[];text=text.slice(at+1);at=0;await seek(true);if(ch==="]"){text=text.slice(at+1);at=0;return returnArr}isFirstKey=true;do{if(isFirstKey){isFirstKey=false}else if(ch===","){text=text.slice(at+1);at=0;await seek(true)}let value=await parseAsync();returnArr.push(value);await seek(true);if(ch==="]"){text=text.slice(at+1);at=0;return returnArr}await seek(true)}while(ch===",");throw error(returnArr.length?"Expected ',' or ']' after array element":"Unexpected end of JSON input");case'"':case"'":case"`":quote=ch;if(text.length<2){if(streamDone){throw error("Unterminated string in JSON")}else{if(wait?.promise){await wait.promise}else{wait.promise=new Promise(resolve=>{wait.resolve=resolve});await wait.promise}wait={};return await parseAsync()}}if(text.charAt(at+1)===quote){const newText=text.slice(at+2);if(!isObject){const trimmedText=newText.trim();if(trimmedText!==""){text=(quote+text).match(/[^ ]* *[^ ]*/)[0];at=text.length-1;throw error("Unexpected non-whitespace character after JSON")}}text=newText;at=0;return""}else{text=text.slice(at+1);at=0;return await normalizeUnicodedString(quote,isObject)}case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"-":case".":case"I":case"+":let numHolder="";let addUpNumberStr=async()=>{numHolder+=ch;await seek()};if(ch==="-"||ch==="+"){await addUpNumberStr()}if(ch==="I"){word=await wordCheck();wordToFind="Infinity";if(word===wordToFind){text=text.slice(at);at=0;numHolder+=word}else{if(text.length>wordToFind.length){at=(numHolder+wordToFind).length+1}else{at=text.indexOf(word)}throw error("Unexpected Token")}}else{let afterDecimal=ch===".";let afterExponential;if(afterDecimal){await addUpNumberStr()}while(isFinite(ch)&&ch!==""){await addUpNumberStr();if(!afterDecimal&&ch==="."){afterDecimal=true;await addUpNumberStr()}else if(!afterExponential&&(ch==="e"||ch==="E")){afterExponential=true;await addUpNumberStr();if(ch==="+"||ch==="-"){await addUpNumberStr()}}}}const num=Number(numHolder);if(isNaN(num)){text=numHolder;at=0;throw error("Invalid Number")}else{const newText=text.slice(at);if(!isObject){const trimmedText=newText.trim();if(trimmedText!==""){at=numHolder.length+1;throw error("Unexpected non-whitespace character after JSON")}}text=newText;at=0;return num}case"t":word=await wordCheck();wordToFind="true";if(word===wordToFind){text=text.slice(at);at=0;return true}else{if(text.length>wordToFind.length){at=wordToFind.length+1}else{at=text.indexOf(word)}throw error("Unexpected Token")}case"f":word=await wordCheck();wordToFind="false";if(word===wordToFind){text=text.slice(at);at=0;return false}else{if(text.length>wordToFind.length){at=wordToFind.length+1}else{at=text.indexOf(word)}throw error("Unexpected Token")}case"n":word=await wordCheck();wordToFind="null";if(word===wordToFind){text=text.slice(at);at=0;return null}else{if(text.length>wordToFind.length){at=wordToFind.length+1}else{at=text.indexOf(word)}throw error("Unexpected Token")}case"u":word=await wordCheck();wordToFind="undefined";if(word===wordToFind){text=text.slice(at);at=0;return undefined}else{if(text.length>wordToFind.length){at=wordToFind.length+1}else{at=text.indexOf(word)}throw error("Unexpected Token")}default:at=0;throw error("Unexpected Token")}}resolve(await parseAsync());streamDone=false})}}