let db;self.onmessage=async({data})=>{try{if(!db)await IDBinit();if(data.name==="animeEntriesIsEmpty"){self.postMessage(jsonIsEmpty(await retrieveJSON("animeEntries")||{}))}else if(data.name==="username"){const userData=await retrieveJSON("userData");self.postMessage(userData?.username??await retrieveJSON("username"))}else if(data.name==="userEntriesLength"){const userData=await retrieveJSON("userData");self.postMessage(((userData?.userEntries??await retrieveJSON("userEntries"))||[]).length)}else if(data.name==="recommendedAnimeListLength"){self.postMessage((await retrieveJSON("recommendedAnimeList")||[]).length)}else if(data.name==="finalAnimeListLength"){const savedFinalAnimeList=await retrieveJSON("savedFinalAnimeList");self.postMessage(((savedFinalAnimeList?.finalAnimeList??await retrieveJSON("finalAnimeList"))||[]).length)}else if(data.name==="aniIdsNotificationToBeUpdated"&&data.aniIdsNotificationToBeUpdated instanceof Array){let aniIdsNotificationToBeUpdated=data?.aniIdsNotificationToBeUpdated?.reduce?.((result,animeId)=>{result[animeId]=true;return result},{});let recommendedAnimeList=await retrieveJSON("recommendedAnimeList")||[];let userAnimeAndNot=recommendedAnimeList?.reduce?.((result,anime)=>{if(anime?.id&&aniIdsNotificationToBeUpdated[anime?.id]){result[anime.id]=anime?.userStatus?.toLowerCase?.()!=="unwatched"}return result},{});self.postMessage(userAnimeAndNot)}else if(data.name){self.postMessage(await retrieveJSON(data.name))}}catch(error){const mainError="Failed to initialize database";console.error(error||mainError);self.postMessage(mainError)}};async function IDBinit(){return await new Promise(resolve=>{request=indexedDB.open("Kanshi.Anime.Recommendations.Anilist.W~uPtWCq=vG$TR:Zl^#t<vdS]I~N70",1);request.onerror=error=>{console.error(error)};request.onsuccess=event=>{db=event.target.result;return resolve()};request.onupgradeneeded=event=>{db=event.target.result;db.createObjectStore("MyObjectStore");let transaction=event.target.transaction;transaction.oncomplete=()=>{return resolve()}}})}async function retrieveJSON(name){return await new Promise((resolve,reject)=>{try{let read=db.transaction("MyObjectStore","readwrite").objectStore("MyObjectStore").get(name);read.onsuccess=()=>{return resolve(read.result)};read.onerror=error=>{console.error(error);return reject(error)}}catch(ex){console.error(ex);return reject(ex)}})}function jsonIsEmpty(obj){for(const key in obj){return false}return true}